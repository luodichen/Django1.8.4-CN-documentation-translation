## 3.2 模型与数据库 ##
模型是一个单一的、确定的数据源，包含数据存储所必要的字段和行为。通常，每个模型都单独对应一个数据表。

### 3.2.1 模型 ###
模型是一个单一的、确定的数据源，包含数据存储所必要的字段和行为。通常，每个模型都单独对应一个数据表。

基本要素：

- 每个模型都是 Python 类 `django.db.models.Model` 的派生类。
- 模型的每个属性都代表数据库的一个字段。
- 基于这些，Django 可以自动生成一组数据库访问的 API，参见[进行查询](?)。

#### 一个简单的示例 ####
下面这个模型示例定义了一个 `Person` 模型，它有 `first_name` 和 `last_name` 两个属性。

    from django.db import models
    class Person(models.Model):
        first_name = models.CharField(max_length=30)
        last_name = models.CharField(max_length=30)

`first_name` 和 `last_name` 是模型的两个[字段](?)。每个字段被定义为一个类的属性，每个属性对应数据库的一列。

上述的 `Person` 模型会像如下的代码一样创建一个数据库表：

    CREATE TABLE myapp_person (
        "id" serial NOT NULL PRIMARY KEY,
        "first_name" varchar(30) NOT NULL,
        "last_name" varchar(30) NOT NULL
    );
    
一些技术说明：

- 数据表的名称 `myqpp_person` 默认情况下会根据模型的某些元数据自动指定，但也可以手动改写它。详细说明参见[数据表名](?)
- `id` 字段会自动被添加，但是这个行为可以由用户自定义。参见[自动生成的主键字段](?)。
- 示例中的 SQL 语句 `CREATE TABLE` 采用的是 PostgreSQL 语法，但值得注意的是 Django 实际使用的 SQL 语句与[配置文件](?)中设置的数据库后端有关。

#### 使用模型 ####
当定义好模型之后，需要告知 Django 这些模型将会被调用。这需要编辑配置文件并修改其中的 [INSTALLED_APPS](?) 设置，添加包含了 `models.py` 的模块名称。

例如一个应用的模型都定义在模块 `myapp.models`（一个应用的这种包结构是由一个 `manage.py startapp` 脚本创建的）中，在 [INSTAllED_APPS](?) 中将看到如下的部分：

    INSTALLED_APPS = (
        #...
        'myapp',
        #...
    )
    
当向 [INSTALLED_APPS](?) 中添加新的 app 后，一定要运行命令 `manage.py migrate`，也可以在这之前先运行迁移命令 [manage.py makemigrations](?)。

#### 字段 ####
模型中最重要的部分——也是唯一必选的部分——是数据库字段定义的列表。字段是由类的属性指定的。在选择字段名称时应当注意不要与[模型 API](?) 的名字例如 `clean`、`save` 或 `delete` 等冲突。

示例：

    from django.db import models
    
    class Musician(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        instrument = models.CharField(max_length=100)
        
    class Album(models.Model):
        artist = models.ForeignKey(Musician)
        name = models.CharField(max_length=100)
        release_date = models.DateField()
        num_stars = models.IntegerField()
        
#### 字段类型 ####
模型中的每个字段都是一个合适的 [Field](?) 类的实例。Django 通过字段类的类别来确定以下几件事：

- 数据库列的类型（例如 `INTEGER`、`VARCHAR`）。
- 当从一个字段渲染 HTML 时默认的 [widget](?)（例如 `<input type="text">,<select>`）。
- 最小的验证要求，这用在 Django admin 自动生成的表单中。

Django 有几十个自带的字段类型，可以在[模型字段参考](?)中找到它们的完整列表。如果 Django 的内置字段类型不适用，你也可以很轻松地写自定义的字段类型，参见[编写自定义的模型字段](?)。

#### 字段选项 ####
每个特定的字段类型都含有一些它独有的参数（在[模型字段参考](?)中有所说明）。例如，`CharField`（和它的子类）需要一个 `max_length` 参数来指定对应数据库中的 `VARCHAR` 字段需要多大的空间来存储数据。

当然，还有一些公共参数是所有类型的字段都需要的，这些字段选项都是可选的，所有这些字段选项都在[参考](?)中有详细的描述，但下面有一个对常用公共字段参数的快速摘要：

[null](?) 如果值为 `True`，Django 会在数据库中将空值存储为 `NULL`。默认值是 `False`。

[blank](?) 如果值为 `True`，这个字段将允许空值。默认值是 `False`。

>请注意这与 `null` 的区别。`null` 是纯数据库相关的，而 `blank` 是程序验证相关的。如果一个字段设置了 `blank=True`，那么表单验证将允许传入一个空值；否则如果一个字段设置了 `blank=False`，那么这个字段是必须有值的。

[choices](?) 是一个由 2-元组 组成的可迭代（例如一个列表或元组）容器，用于标识这个字段可用的选项。如果设置了这个选项，默认的表单 widget 会是一个选择框而不是一个标准的文本框，并且，选择框的选项会被限定在指定的范围内。

一个 choices 列表示例如下所示：

    YEAR_IN_SCHOOL_CHOICES = (
        ('FR', 'Freshman'),
        ('SO', 'Sophomore'),
        ('JR', 'Junior'),
        ('SR', 'Senior'),
        ('GR', 'Graduate'),
    )
    
列表中每个元组的第一个元素的值是存在数据库中的，第二个元素将显示在默认的表单 widget 中，或在一个 ModelChoiseField 中。对于一个给定的模型对象实例，一个 choices 字段的显示值可以用 `get_FOO_display` 方法获取，例如：

    from django.db import models
    class Person(models.Model):
        SHIRT_SIZES = (
            ('S', 'Small'),
            ('M', 'Medium'),
            ('L', 'Large'),
        )
        name = models.CharField(max_length=60)
        shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
        
    >>> p = Person(name="Fred Flintstone", shirt_size="L")
    >>> p.save()
    >>> p.shirt_size
    'L'
    >>> p.get_shirt_size_display()
    'Large'
    
[default](?) 一个字段的默认值。它可以是一个简单的值或一个可调用的对象，当它是可调用对象时，它会在每次新对象被创建的时候被调用。

[help_text](?) 额外的“帮助”文本会显示在表单 widget 中。即使字段没有运用在表单中，这也可以当作有用的文档使用。

[primary_key](?) 如果值为 `True`，这个字段会被当作模型的主键。

>如果没有模型中的对任何一个字段设置 [primary_key=True](?)，Django 会自动添加一个 [IntegerField](?) 作为主键，因此除非希望覆盖默认的主键行为，不必自行创建一个 `primary_key=True` 的字段。参见[自动主键字段](?)获取更多信息。
>
>主键字段是只读的。如果试图修改一个已经存在的对象的主键字段值，然后保存它，一个基于旧对象的新对象将会被创建。如下面的示例：

        from django.db import models
        class Fruit(models.Model):
            name = models.CharField(max_length=100, primary_key=True)
            
        >>> fruit = Fruit.objects.create(name='Apple')
        >>> fruit.name = 'Pear'
        >>> fruit.save()
        >>> Fruit.objects.values_list('name', flat=True)
        ['Apple', 'Pear']
            
[unique](?) 如果值为 `True`，这个字段在整个数据表中是唯一的。

再次声明，这些只是大多数公共字段选项的一个简短描述，有关完整的详细信息可以在[公共模型字段选项参考](?)中找到。

#### 自动主键字段 ####
默认情况下，Django 会为每个模型添加如下一个字段：

    id = models.AutoField(primary_key=True)

这是一个自增长的主键。

如果想要指定一个自定义的主键字段，只要为那个字段指定 `primary_key=True` 即可。当 Django 发现你明确地设置了 `Field.primary_key` 时，它将不会再自动添加 `id` 列。

每个模型都需要有且仅有一个字段被设置为 `primary_key=True`（包括明确定义的和自动生成的）。

#### 详细字段名 ####
除了 `ForeignKey`、`ManyToManyField` 和 `OneToOneField` 之外，每种类型的字段第一个参数参数都是详细字段名。如果详细字段名没有指定，Django 会自动将其指定为这个字段的属性名称，并将下划线替换为空格。

