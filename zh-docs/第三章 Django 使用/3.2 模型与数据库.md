## 3.2 模型与数据库 ##
模型是一个单一的、确定的数据源，包含数据存储所必要的字段和行为。通常，每个模型都单独对应一个数据表。

### 3.2.1 模型 ###
模型是一个单一的、确定的数据源，包含数据存储所必要的字段和行为。通常，每个模型都单独对应一个数据表。

基本要素：

- 每个模型都是 Python 类 `django.db.models.Model` 的派生类。
- 模型的每个属性都代表数据库的一个字段。
- 基于这些，Django 可以自动生成一组数据库访问的 API，参见[进行查询](?)。

#### 一个简单的示例 ####
下面这个模型示例定义了一个 `Person` 模型，它有 `first_name` 和 `last_name` 两个属性。

    from django.db import models
    class Person(models.Model):
        first_name = models.CharField(max_length=30)
        last_name = models.CharField(max_length=30)

`first_name` 和 `last_name` 是模型的两个[字段](?)。每个字段被定义为一个类的属性，每个属性对应数据库的一列。

上述的 `Person` 模型会像如下的代码一样创建一个数据库表：

    CREATE TABLE myapp_person (
        "id" serial NOT NULL PRIMARY KEY,
        "first_name" varchar(30) NOT NULL,
        "last_name" varchar(30) NOT NULL
    );
    
一些技术说明：

- 数据表的名称 `myqpp_person` 默认情况下会根据模型的某些元数据自动指定，但也可以手动改写它。详细说明参见[数据表名](?)
- `id` 字段会自动被添加，但是这个行为可以由用户自定义。参见[自动生成的主键字段](?)。
- 示例中的 SQL 语句 `CREATE TABLE` 采用的是 PostgreSQL 语法，但值得注意的是 Django 实际使用的 SQL 语句与[配置文件](?)中设置的数据库后端有关。

#### 使用模型 ####
当定义好模型之后，需要告知 Django 这些模型将会被调用。这需要编辑配置文件并修改其中的 [INSTALLED_APPS](?) 设置，添加包含了 `models.py` 的模块名称。

例如一个应用的模型都定义在模块 `myapp.models`（一个应用的这种包结构是由一个 `manage.py startapp` 脚本创建的）中，在 [INSTAllED_APPS](?) 中将看到如下的部分：

    INSTALLED_APPS = (
        #...
        'myapp',
        #...
    )
    
当向 [INSTALLED_APPS](?) 中添加新的 app 后，一定要运行命令 `manage.py migrate`，也可以在这之前先运行迁移命令 [manage.py makemigrations](?)。

#### 字段 ####
模型中最重要的部分——也是唯一必选的部分——是数据库字段定义的列表。字段是由类的属性指定的。在选择字段名称时应当注意不要与[模型 API](?) 的名字例如 `clean`、`save` 或 `delete` 等冲突。

示例：

    from django.db import models
    
    class Musician(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        instrument = models.CharField(max_length=100)
        
    class Album(models.Model):
        artist = models.ForeignKey(Musician)
        name = models.CharField(max_length=100)
        release_date = models.DateField()
        num_stars = models.IntegerField()
        
#### 字段类型 ####
模型中的每个字段都是一个合适的 [Field](?) 类的实例。Django 通过字段类的类别来确定以下几件事：

- 数据库列的类型（例如 `INTEGER`、`VARCHAR`）。
- 当从一个字段渲染 HTML 时默认的 [widget](?)（例如 `<input type="text">,<select>`）。
- 最小的验证要求，这用在 Django admin 自动生成的表单中。

Django 有几十个自带的字段类型，可以在[模型字段参考](?)中找到它们的完整列表。如果 Django 的内置字段类型不适用，你也可以很轻松地写自定义的字段类型，参见[编写自定义的模型字段](?)。

#### 字段选项 ####
每个特定的字段类型都含有一些它独有的参数（在[模型字段参考](?)中有所说明）。例如，`CharField`（和它的子类）需要一个 `max_length` 参数来指定对应数据库中的 `VARCHAR` 字段需要多大的空间来存储数据。

当然，还有一些公共参数是所有类型的字段都需要的，这些字段选项都是可选的，所有这些字段选项都在[参考](?)中有详细的描述，下面还有一个常用公共字段参数的快速摘要：

[null](?) 如果值为 `True`，Django 会在数据库中将空值存储为 `NULL`。默认值是 `False`。

[blank](?) 如果值为 `True`，这个字段将允许空值。默认值是 `False`。

>请注意这与 `null` 的区别。`null` 是纯数据库相关的，而 `blank` 是程序验证相关的。如果一个字段设置了 `blank=True`，那么表单验证将允许传入一个空值；否则如果一个字段设置了 `blank=False`，那么这个字段是必须有值的。

[choices](?) 是一个由 2-元组 组成的可迭代（例如一个列表或元组）容器，用于标识这个字段可用的选项。如果设置了这个选项，默认的表单 widget 会是一个选择框而不是一个标准的文本框，并且，选择框的选项会被限定在指定的范围内。

一个 choices 列表示例如下所示：

    YEAR_IN_SCHOOL_CHOICES = (
        ('FR', 'Freshman'),
        ('SO', 'Sophomore'),
        ('JR', 'Junior'),
        ('SR', 'Senior'),
        ('GR', 'Graduate'),
    )
    
列表中每个元组的第一个元素的值是存在数据库中的，第二个元素将显示在默认的表单 widget 中，或在一个 ModelChoiseField 中。对于一个给定的模型对象实例，一个 choices 字段的显示值可以用 `get_FOO_display` 方法获取，例如：

    from django.db import models
    class Person(models.Model):
        SHIRT_SIZES = (
            ('S', 'Small'),
            ('M', 'Medium'),
            ('L', 'Large'),
        )
        name = models.CharField(max_length=60)
        shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
        
    >>> p = Person(name="Fred Flintstone", shirt_size="L")
    >>> p.save()
    >>> p.shirt_size
    'L'
    >>> p.get_shirt_size_display()
    'Large'
    
[default](?) 一个字段的默认值。它可以是一个简单的值或一个可调用的对象，当它是可调用对象时，它会在每次新对象被创建的时候被调用。

[help_text](?) 额外的“帮助”文本会显示在表单 widget 中。即使字段没有运用在表单中，这也可以当作有用的文档使用。

[primary_key](?) 如果值为 `True`，这个字段会被当作模型的主键。

>如果没有模型中的对任何一个字段设置 [primary_key=True](?)，Django 会自动添加一个 [IntegerField](?) 作为主键，因此除非希望覆盖默认的主键行为，不必自行创建一个 `primary_key=True` 的字段。参见[自动主键字段](?)获取更多信息。
>
>主键字段是只读的。如果试图修改一个已经存在的对象的主键字段值，然后保存它，一个基于旧对象的新对象将会被创建。如下面的示例：

        from django.db import models
        class Fruit(models.Model):
            name = models.CharField(max_length=100, primary_key=True)
            
        >>> fruit = Fruit.objects.create(name='Apple')
        >>> fruit.name = 'Pear'
        >>> fruit.save()
        >>> Fruit.objects.values_list('name', flat=True)
        ['Apple', 'Pear']
            
[unique](?) 如果值为 `True`，这个字段在整个数据表中是唯一的。

再次声明，这些只是大多数公共字段选项的一个简短描述，有关完整的详细信息可以在[公共模型字段选项参考](?)中找到。

#### 自动主键字段 ####
默认情况下，Django 会为每个模型添加如下一个字段：

    id = models.AutoField(primary_key=True)

这是一个自增长的主键。

如果想要指定一个自定义的主键字段，只要为那个字段指定 `primary_key=True` 即可。当 Django 发现你明确地设置了 `Field.primary_key` 时，它将不会再自动添加 `id` 列。

每个模型都需要有且仅有一个字段被设置为 `primary_key=True`（包括明确定义的和自动生成的）。

#### 详细字段名 ####
除了 [ForeignKey](?)、[ManyToManyField](?) 和 [OneToOneField](?) 之外，每种类型的字段第一个参数参数都是详细字段名。如果详细字段名没有指定，Django 会自动将其指定为这个字段的属性名称，并将下划线替换为空格。

以下示例中的详细字段名是 `"person's first name"`。

    first_name = models.CharField("person's first name", max_length=30)
    
以下示例中的详细字段名是 `"first name"`。

    first_name = models.CharField(max_length=30)
    
[ForeignKey](?)、[ManyToManyField](?) 和 [OneToOneField](?) 的第一个参数是模型类，因此要用关键字参数 [verbose_name](?) 指定详细字段名。例如：

    poll = models.ForeignKey(Poll, verbose_name="the related poll")
    sites = models.ManyToManyField(Site, verbose_name="list of sites")
    place = models.OneToOneField(Place, verbose_name="related place")

习惯上不大写 [verbose_name](?) 的首字母，当有必要时，Django 会自动大写它。

#### 关联 ####
显而易见的，关系型数据库的强大之处在于它将表与表之间关联了起来。Django 提供了多对一、多对多和单对单三种最常见的数据库关系的定义方式。

**多对一关系** 用 [django.db.models.ForeignKey](?) 来定义一个多对一关系。与其他[字段](?)类型一样，在模型中创建一个值为 `ForeignKey` 对象的类属性，就可以定义一个多对一关系。

[ForeignKey](?) 的第一个参数是被关联的模型的类，这是一个必选参数。

例如，如果每辆汽车（模型 `Car`）都由一家生产厂家（模型 `Manufacturer`）来生产——这意味着一个生产厂家对对应多辆汽车，但一辆汽车只对应一家生产厂家——可以用如下的定义来表示这个关联关系：

    from django.db import models
    class Manufacturer(models.Model):
        # ...
        pass
    class Car(models.Model):
        manufacturer = models.ForeignKey(Manufacturer)
        # ...
        
Django 允许创建[递归关联](?)（一个对象与它自身存在多对一关系）以及[关联到一个暂未定义的模型](?)，详情参见[模型关联字段](?)。

建议将 [ForeignKey](?) 命名为它关联的模型的类名，并将全部字母改为小写。但这不是必需的，当然也可以为它起任何其他名字，例如：

    class Car(models.Model):
        company_that_makes_it = models.ForeignKey(Manufacturer)
        # ...
        
** 更多请参阅： **

[ForeignKey](?) 字段还可以接受多个额外的参数，这些参数在[模型字段参考](?)中有所说明，这些选项定义一个关联应该如何运作，所有这些参数都是可选的。

关于访问反向关联对象的细节，请参阅[访问反向关联示例](?)。

示例代码请参阅[多对一关联模型示例](?)。

** 多对多关系 ** 用 [ManyToManyField](?) 来定义一个多对多关系。与其他[字段](?)类型一样，在模型中创建一个值为 `ManyToManyField` 对象的类属性，就可以定义一个多对多关系。

[ManyToManyField](?) 的第一个参数是被关联的模型的类，这是一个必选参数。

例如，一种比萨饼（模型 `Pizza`）拥有多种馅料（模型 `Topping`）——这意味着一种馅料会对应多个比萨饼，而每种比萨饼也会对应多种馅料——可以用如下的代码来表示这种情况：

    from django.db import models
    class Topping(models.Model):
        # ...
        pass
    class Pizza(models.Model):
        # ...
        toppings = models.ManyToManyField(Topping)

对于一个 [ForeignKey](?)（实应为[ManyToManyField](?)，译者注），Django 允许创建[递归关联](?)（一个对象与它自身存在多对多关系）以及[关联到一个暂未定义的模型](?)，详情参见[模型关联字段](?)。

建议将 [ManyToManyField](?) 的属性名称命名为它关联的模型对象的复数形式（在上面的例子中应为 `toppings`），但这不是必需的。

在多对多关系的两个模型中，只能在其中任意一个模型中设置指向对方的 [ManyToManyField](?) 字段，而不能在两个模型中都这样做。

通常，[ManyToManyField](?) 字段应该设置在存在于备选项表单的模型中。在上述例子中，应当在 `Pizza` 模型中设置 `toppings` 字段（而不是在 `Topping` 模型中设置 `pizzas` 字段），因为“一种比萨上有多种馅料”比“每种馅料都存在于多种比萨上”更直观。这么做的理由是，通常用户是在一个比萨表单上选择他喜欢的几种馅料。

** 更多请参阅： **

参考完整的[多对多关系模型示例](?)。

[ManyToManyField](?) 字段还可以接受多个额外的参数，这些参数在[模型字段参考](?)中有所说明，这些选项定义一个关联应该如何运作，所有这些参数都是可选的。

** 多个多对多关系字段 **